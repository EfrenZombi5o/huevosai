<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>AI Assistant with Voice & Code Typing + Chat Delete</title>
<script src="https://js.puter.com/v2/"></script>

<!-- Prism CSS for syntax highlighting -->
<link href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism-tomorrow.css" rel="stylesheet" />

<style>
  /* --- Styles --- */
  :root {
    --bg-light: #f9f9f9;
    --bg-dark: #121212;
    --text-light: #222;
    --text-dark: #eee;
    --user-bubble-light: #d1e7ff;
    --assistant-bubble-light: #e9ecef;
    --user-bubble-dark: #2a4d7d;
    --assistant-bubble-dark: #444;
    --primary: #007bff;
    --primary-dark: #0056b3;
    --input-bg-light: #fff;
    --input-bg-dark: #2a2a2a;
  }
  body {
    margin: 0;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    background: var(--bg-light);
    color: var(--text-light);
    display: flex;
    height: 100vh;
    overflow: hidden;
  }
  body.dark {
    background: var(--bg-dark);
    color: var(--text-dark);
  }
  #sidebar {
    width: 250px;
    background: inherit;
    border-right: 1px solid #ccc;
    display: flex;
    flex-direction: column;
  }
  #sidebar.dark {
    border-color: #444;
  }
  #chatListHeader {
    padding: 1em;
    font-weight: 700;
    font-size: 1.2em;
    border-bottom: 1px solid #ccc;
  }
  #chatListHeader.dark {
    border-color: #444;
  }
  #chatList {
    flex: 1;
    overflow-y: auto;
    padding: 0.5em 1em;
  }
  #chatList li {
    position: relative;
    list-style: none;
    padding: 0.5em 0.75em;
    border-radius: 6px;
    cursor: pointer;
    margin-bottom: 0.3em;
    background: var(--assistant-bubble-light);
    color: var(--text-light);
    font-weight: 600;
    user-select: none;
  }
  #chatList li.dark {
    background: var(--assistant-bubble-dark);
    color: var(--text-dark);
  }
  #chatList li.active {
    background: var(--primary);
    color: white;
  }

  /* Delete button in chat list */
  #chatList li .delete-btn {
    position: absolute;
    top: 4px;
    right: 8px;
    font-weight: bold;
    color: #888;
    cursor: pointer;
    user-select: none;
    font-size: 1.1em;
    padding: 0 4px;
    border-radius: 4px;
    transition: color 0.2s ease;
  }
  #chatList li .delete-btn:hover {
    color: #f44336;
  }

  #newChatForm {
    padding: 0.5em 1em;
    border-top: 1px solid #ccc;
  }
  #newChatForm.dark {
    border-color: #444;
  }
  #newChatName {
    width: 100%;
    padding: 0.4em 0.6em;
    border-radius: 6px;
    border: 1px solid #ccc;
    font-size: 1em;
    background: var(--input-bg-light);
    color: var(--text-light);
  }
  #newChatName.dark {
    border-color: #555;
    background: var(--input-bg-dark);
    color: var(--text-dark);
  }
  #createChatBtn {
    margin-top: 0.5em;
    width: 100%;
    padding: 0.5em;
    border: none;
    border-radius: 6px;
    background-color: var(--primary);
    color: white;
    font-weight: 600;
    cursor: pointer;
    transition: background-color 0.3s ease;
  }
  #createChatBtn:hover {
    background-color: var(--primary-dark);
  }

  #main {
    flex: 1;
    display: flex;
    flex-direction: column;
  }
  #chat {
    flex: 1;
    overflow-y: auto;
    padding: 1em;
    display: flex;
    flex-direction: column;
    gap: 0.75em;
    background: inherit;
  }
  .bubble {
    max-width: 70%;
    padding: 0.75em 1em;
    border-radius: 20px;
    line-height: 1.4;
    white-space: pre-wrap;
    word-wrap: break-word;
  }
  .user {
    align-self: flex-end;
    background-color: var(--user-bubble-light);
    color: var(--text-light);
    border-bottom-right-radius: 4px;
  }
  .assistant {
    align-self: flex-start;
    background-color: var(--assistant-bubble-light);
    color: var(--text-light);
    border-bottom-left-radius: 4px;
  }
  body.dark .user {
    background-color: var(--user-bubble-dark);
    color: #cce4ff;
  }
  body.dark .assistant {
    background-color: var(--assistant-bubble-dark);
    color: var(--text-dark);
  }

  #status {
    font-size: 0.9em;
    color: gray;
    padding: 0 1em 0.5em;
    min-height: 1.2em;
  }

  #input-area {
    display: flex;
    padding: 0.5em 1em;
    border-top: 1px solid #ccc;
    background: inherit;
  }
  body.dark #input-area {
    border-color: #444;
  }
  #prompt {
    flex: 1;
    padding: 0.5em 1em;
    font-size: 1em;
    border-radius: 20px;
    border: 1px solid #ccc;
    outline: none;
    resize: none;
    font-family: inherit;
    background: var(--input-bg-light);
    color: var(--text-light);
  }
  body.dark #prompt {
    border-color: #555;
    background: var(--input-bg-dark);
    color: var(--text-dark);
  }
  #prompt:focus {
    border-color: var(--primary);
  }
  button {
    margin-left: 0.5em;
    padding: 0 1em;
    font-size: 1em;
    border-radius: 20px;
    border: none;
    background-color: var(--primary);
    color: white;
    cursor: pointer;
    transition: background-color 0.3s ease;
  }
  button:hover {
    background-color: var(--primary-dark);
  }

  #controls {
    display: flex;
    align-items: center;
    padding: 0.5em 1em;
    border-top: 1px solid #ccc;
    background: inherit;
    gap: 0.5em;
    flex-wrap: wrap;
  }
  body.dark #controls {
    border-color: #444;
  }
  select, input[type="text"] {
    font-size: 1em;
    padding: 0.3em 0.5em;
    border-radius: 6px;
    border: 1px solid #ccc;
    background: var(--input-bg-light);
    color: var(--text-light);
  }
  body.dark select, body.dark input[type="text"] {
    border-color: #555;
    background: var(--input-bg-dark);
    color: var(--text-dark);
  }

  /* Fix for select dropdown text visibility */
  select {
    color: inherit;
    background-color: inherit;
  }
  select option {
    color: var(--text-light);
    background-color: var(--input-bg-light);
  }
  body.dark select option {
    color: var(--text-dark);
    background-color: var(--input-bg-dark);
  }

  #darkModeToggle, #voiceToggle {
    cursor: pointer;
    background: none;
    border: none;
    font-size: 1.4em;
    color: var(--primary);
  }
  #darkModeToggle:hover, #voiceToggle:hover {
    color: var(--primary-dark);
  }
  #imageUrl {
    flex: 1 1 250px;
  }
  #modelSelect {
    flex: 1 1 200px;
  }

  /* Mic permission prompt styles */
  #micPermissionPrompt {
    position: fixed;
    top: 0; left: 0; width: 100vw; height: 100vh;
    background: rgba(0,0,0,0.6);
    display: none;
    align-items: center;
    justify-content: center;
    z-index: 10000;
  }
  #micPermissionPrompt > div {
    background: #fff;
    padding: 20px;
    border-radius: 8px;
    max-width: 320px;
    text-align: center;
    color: #000;
  }
  #micPermissionPrompt button {
    padding: 10px 20px;
    margin: 10px 5px 0 5px;
    cursor: pointer;
  }

  /* Code box styling for typed code */
  .code-box {
    background: #2d2d2d;
    border-radius: 8px;
    padding: 1em 1.5em;
    margin: 0.5em 0;
    max-height: 300px;
    overflow-y: auto;
    font-family: 'Fira Code', monospace, monospace;
    font-size: 0.9rem;
    line-height: 1.4;
    white-space: pre-wrap;
    box-shadow: 0 0 15px rgba(0,0,0,0.7);
    color: #ccc;
  }
</style>
</head>
<body>

<div id="sidebar">
  <div id="chatListHeader">Chats</div>
  <ul id="chatList"></ul>
  <form id="newChatForm">
    <input type="text" id="newChatName" placeholder="New chat name" autocomplete="off" />
    <button type="submit" id="createChatBtn">Create Chat</button>
  </form>
</div>

<div id="main">
  <div id="chat"></div>
  <div id="status"></div>
  <div id="input-area">
    <textarea id="prompt" rows="2" placeholder="Type your message..."></textarea>
    <button id="voiceInputBtn" title="Voice Input">üé§</button>
    <button id="sendBtn" title="Send Message">‚û°Ô∏è</button>
  </div>
  <div id="controls">
    <input type="text" id="imageUrl" placeholder="Optional image URL to analyze" />
    <select id="modelSelect" title="Select AI Model">
      <optgroup label="DeepSeek Models">
        <option value="deepseek-chat">DeepSeek Chat (DeepSeek V3)</option>
        <option value="deepseek-reasoner">DeepSeek Reasoner (DeepSeek R1)</option>
      </optgroup>
      <optgroup label="Gemini Models">
        <option value="google/gemini-2.5-pro-exp-03-25:free">Gemini 2.5 Pro</option>
        <option value="google/gemini-2.0-flash-lite-001">Gemini 2.0 Flash Lite</option>
        <option value="google/gemini-flash-1.5-8b">Gemini 1.5 Flash</option>
      </optgroup>
      <optgroup label="OpenAI-Compatible Models">
        <option value="gpt-4o">GPT-4o</option>
        <option value="gpt-4.1">GPT-4.1</option>
        <option value="o3-mini">o3-mini</option>
        <option value="o1-mini">o1-mini</option>
        <option value="gpt-4.5-preview">GPT-4.5 Preview</option>
      </optgroup>
    </select>
    <button id="generateImageBtn" title="Generate Image">üñºÔ∏è</button>
    <button id="voiceToggle" title="Toggle Assistant Voice">üîä</button>
    <button id="darkModeToggle" title="Toggle Dark Mode">üåô</button>
  </div>
</div>

<!-- Mic permission prompt -->
<div id="micPermissionPrompt">
  <div>
    <p>This app needs access to your microphone to enable voice input.</p>
    <button id="allowMicBtn">Allow Microphone</button>
    <button id="denyMicBtn">Cancel</button>
  </div>
</div>

<!-- Prism JS -->
<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.js"></script>
<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-javascript.min.js"></script>

<script>
  // Elements
  const chatListEl = document.getElementById('chatList');
  const newChatForm = document.getElementById('newChatForm');
  const newChatNameInput = document.getElementById('newChatName');
  const chatDiv = document.getElementById('chat');
  const promptInput = document.getElementById('prompt');
  const sendBtn = document.getElementById('sendBtn');
  const voiceInputBtn = document.getElementById('voiceInputBtn');
  const imageUrlInput = document.getElementById('imageUrl');
  const modelSelect = document.getElementById('modelSelect');
  const generateImageBtn = document.getElementById('generateImageBtn');
  const darkModeToggle = document.getElementById('darkModeToggle');
  const voiceToggle = document.getElementById('voiceToggle');
  const statusDiv = document.getElementById('status');
  const sidebar = document.getElementById('sidebar');

  // Mic permission prompt elements
  const micPermissionPrompt = document.getElementById('micPermissionPrompt');
  const allowMicBtn = document.getElementById('allowMicBtn');
  const denyMicBtn = document.getElementById('denyMicBtn');

  // State variables
  let chats = {};
  let currentChatId = null;
  let recognition = null;
  let isListening = false;
  let synth = window.speechSynthesis;
  let assistantVoiceEnabled = true;

  // Utility delay function
  const delay = ms => new Promise(res => setTimeout(res, ms));

  // Load chats from localStorage
  function loadChats() {
    const saved = localStorage.getItem('personal_ai_chats');
    if (saved) {
      try {
        chats = JSON.parse(saved);
      } catch {
        chats = {};
      }
    }
  }

  // Save chats to localStorage
  function saveChats() {
    localStorage.setItem('personal_ai_chats', JSON.stringify(chats));
  }

  // Generate unique chat ID
  function generateId() {
    return 'chat_' + Math.random().toString(36).slice(2, 10);
  }

  // Render chat list with delete buttons
  function renderChatList() {
    chatListEl.innerHTML = '';
    for (const [id, chat] of Object.entries(chats)) {
      const li = document.createElement('li');
      li.textContent = chat.name;
      li.dataset.chatId = id;
      li.classList.toggle('active', id === currentChatId);
      if(document.body.classList.contains('dark')) li.classList.add('dark');

      // Click to switch chat (ignore clicks on delete button)
      li.addEventListener('click', e => {
        if (e.target.classList.contains('delete-btn')) return;
        switchChat(id);
      });

      // Delete button
      const delBtn = document.createElement('span');
      delBtn.textContent = '√ó';
      delBtn.className = 'delete-btn';
      delBtn.title = 'Delete chat';
      delBtn.addEventListener('click', e => {
        e.stopPropagation();
        if (confirm(`Are you sure you want to delete chat "${chat.name}"? This action cannot be undone.`)) {
          delete chats[id];
          saveChats();
          if (currentChatId === id) {
            const remainingIds = Object.keys(chats);
            if (remainingIds.length > 0) {
              switchChat(remainingIds[0]);
            } else {
              createNewChat('Default Chat');
            }
          } else {
            renderChatList();
          }
        }
      });

      li.appendChild(delBtn);
      chatListEl.appendChild(li);
    }
  }

  // Switch to a chat by ID
  function switchChat(id) {
    if (!chats[id]) return;
    currentChatId = id;
    renderChatList();
    loadChatToUI();
  }

  // Load chat messages and model into UI
  async function loadChatToUI() {
    if (!currentChatId) return;
    const chat = chats[currentChatId];
    promptInput.value = '';
    imageUrlInput.value = '';
    modelSelect.value = chat.model || 'deepseek-chat';
    statusDiv.textContent = '';
    await renderMessages();
  }

  // Render messages with typing animation for code blocks
  async function renderMessages() {
    if (!currentChatId) return;
    chatDiv.innerHTML = '';
    const chat = chats[currentChatId];

    for (const msg of chat.messages) {
      if (msg.role === 'assistant' && msg.text.startsWith('```') && msg.text.endsWith('```')) {
        // Extract code inside triple backticks
        const codeContent = msg.text.replace(/^```(\w+)?\n?/, '').replace(/```$/, '');
        const langMatch = msg.text.match(/^```(\w+)/);
        const langClass = langMatch ? `language-${langMatch[1]}` : 'language-javascript';

        const pre = document.createElement('pre');
        pre.className = 'code-box';
        const code = document.createElement('code');
        code.className = langClass;
        pre.appendChild(code);
        chatDiv.appendChild(pre);

        code.textContent = '';
        for (let i = 0; i < codeContent.length; i++) {
          code.textContent += codeContent.charAt(i);
          pre.scrollTop = pre.scrollHeight;
          chatDiv.scrollTop = chatDiv.scrollHeight;
          await delay(15);
        }
        Prism.highlightElement(code);

      } else {
        const bubble = document.createElement('div');
        bubble.className = 'bubble ' + msg.role;
        bubble.textContent = msg.text;
        chatDiv.appendChild(bubble);
        chatDiv.scrollTop = chatDiv.scrollHeight;
        await delay(50);
      }
    }
  }

  // Add message to current chat
  function addMessage(role, text) {
    if (!currentChatId) return;
    const chat = chats[currentChatId];
    chat.messages.push({role, text});
    if (chat.messages.length > 50) chat.messages.shift();
    saveChats();
  }

  // Create a new chat
  function createNewChat(name) {
    if (!name.trim()) {
      alert('Enter a chat name');
      return;
    }
    const id = generateId();
    chats[id] = {
      name: name.trim(),
      messages: [],
      model: 'deepseek-chat'
    };
    saveChats();
    switchChat(id);
    newChatNameInput.value = '';
  }

  // Build context prompt from chat history + new user message
  function buildContextPrompt(newUserMessage) {
    if (!currentChatId) return newUserMessage;
    const chat = chats[currentChatId];
    let context = '';
    chat.messages.forEach(msg => {
      context += `${msg.role === 'user' ? 'User' : 'Assistant'}: ${msg.text}\n`;
    });
    context += `User: ${newUserMessage}\nAssistant:`;
    return context;
  }

  // Send user query and stream assistant response
  async function sendQuery() {
    const prompt = promptInput.value.trim();
    const imageUrl = imageUrlInput.value.trim();
    const model = modelSelect.value;

    if (!prompt && !imageUrl) {
      alert('Please enter a message or image URL.');
      return;
    }

    addMessage('user', prompt || '[Image URL provided]');
    promptInput.value = '';
    statusDiv.textContent = 'Thinking...';
    await renderMessages();

    if (currentChatId) {
      chats[currentChatId].model = model;
      saveChats();
    }

    try {
      let responseStream;
      if (imageUrl) {
        const fullPrompt = prompt || 'Describe this image';
        const contextPrompt = buildContextPrompt(fullPrompt);
        responseStream = await puter.ai.chat(contextPrompt, imageUrl, { model, stream: true });
      } else {
        const contextPrompt = buildContextPrompt(prompt);
        responseStream = await puter.ai.chat(contextPrompt, { model, stream: true });
      }

      let assistantReply = '';
      addMessage('assistant', ''); // placeholder for streaming response
      await renderMessages();

      const chat = chats[currentChatId];
      const lastMsgIndex = chat.messages.length - 1;

      for await (const part of responseStream) {
        if (part?.text) {
          assistantReply += part.text;
          chat.messages[lastMsgIndex].text = assistantReply;
          saveChats();
          await renderMessages();
        }
      }

      statusDiv.textContent = '';
      if (assistantVoiceEnabled) speakText(assistantReply);

    } catch (e) {
      statusDiv.textContent = 'Error: ' + e.message;
    }
  }

  // Generate image from prompt
  async function generateImage() {
    const prompt = promptInput.value.trim();
    if (!prompt) {
      alert('Enter prompt to generate image.');
      return;
    }
    statusDiv.textContent = 'Generating image...';
    try {
      const img = await puter.ai.txt2img(prompt);
      addMessage('user', prompt);
      addMessage('assistant', '[Image generated below]');
      await renderMessages();
      const imgElem = document.createElement('img');
      imgElem.src = img.src;
      imgElem.style.maxWidth = '100%';
      chatDiv.appendChild(imgElem);
      chatDiv.scrollTop = chatDiv.scrollHeight;
      statusDiv.textContent = 'Image generated.';
      promptInput.value = '';
    } catch (e) {
      statusDiv.textContent = 'Error generating image.';
    }
  }

  // Setup voice recognition with toggle and permission prompt
  function setupVoiceRecognition() {
    if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
      voiceInputBtn.disabled = true;
      voiceInputBtn.title = 'Voice input not supported in this browser';
      statusDiv.textContent = 'Voice input not supported in this browser.';
      return;
    }
    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
    recognition = new SpeechRecognition();
    recognition.lang = 'en-US';
    recognition.interimResults = false;
    recognition.maxAlternatives = 1;

    recognition.onstart = () => {
      isListening = true;
      voiceInputBtn.textContent = 'üéôÔ∏è Listening... (click to stop)';
      statusDiv.textContent = 'Listening...';
    };
    recognition.onend = () => {
      isListening = false;
      voiceInputBtn.textContent = 'üé§';
      statusDiv.textContent = '';
    };
    recognition.onerror = (e) => {
      console.error('Voice input error:', e.error);
      statusDiv.textContent = 'Voice input error: ' + e.error;
      isListening = false;
      voiceInputBtn.textContent = 'üé§';
      if (e.error === 'not-allowed' || e.error === 'permission-denied') {
        alert('Microphone access denied. Please allow microphone permissions and reload the page.');
      }
    };
    recognition.onresult = (e) => {
      const transcript = e.results[0][0].transcript;
      promptInput.value = transcript;
      statusDiv.textContent = 'You said: ' + transcript;
    };
  }

  // Show/hide mic permission prompt
  function showMicPermissionPrompt() {
    micPermissionPrompt.style.display = 'flex';
  }

  function hideMicPermissionPrompt() {
    micPermissionPrompt.style.display = 'none';
  }

  // Toggle voice input listening with permission prompt
  function toggleVoiceInput() {
    if (!recognition) return;
    if (isListening) {
      recognition.stop();
    } else {
      showMicPermissionPrompt();
    }
  }

  // Toggle assistant voice on/off
  function toggleAssistantVoice() {
    assistantVoiceEnabled = !assistantVoiceEnabled;
    voiceToggle.textContent = assistantVoiceEnabled ? 'üîä' : 'üîà';
    localStorage.setItem('assistantVoiceEnabled', assistantVoiceEnabled ? 'true' : 'false');
  }

  // Load assistant voice preference
  function loadAssistantVoicePref() {
    const val = localStorage.getItem('assistantVoiceEnabled');
    assistantVoiceEnabled = val !== 'false';
    voiceToggle.textContent = assistantVoiceEnabled ? 'üîä' : 'üîà';
  }

  // Text-to-speech for assistant voice
  function speakText(text) {
    if (!synth) return;
    if (synth.speaking) synth.cancel();
    if (!text) return;
    const utterance = new SpeechSynthesisUtterance(text);
    utterance.lang = 'en-US';
    synth.speak(utterance);
  }

  // Dark mode toggle
  function toggleDarkMode() {
    document.body.classList.toggle('dark');
    sidebar.classList.toggle('dark');
    newChatNameInput.classList.toggle('dark');
    newChatForm.classList.toggle('dark');
    chatListEl.querySelectorAll('li').forEach(li => li.classList.toggle('dark'));
    if (document.body.classList.contains('dark')) {
      darkModeToggle.textContent = '‚òÄÔ∏è';
      localStorage.setItem('darkMode', 'true');
    } else {
      darkModeToggle.textContent = 'üåô';
      localStorage.setItem('darkMode', 'false');
    }
  }

  // Load dark mode preference
  function loadDarkMode() {
    if (localStorage.getItem('darkMode') === 'true') {
      document.body.classList.add('dark');
      sidebar.classList.add('dark');
      newChatNameInput.classList.add('dark');
      newChatForm.classList.add('dark');
      darkModeToggle.textContent = '‚òÄÔ∏è';
    } else {
      darkModeToggle.textContent = 'üåô';
    }
  }

  // Initialize app
  function init() {
    loadChats();
    if (Object.keys(chats).length === 0) {
      createNewChat('Default Chat');
    } else {
      switchChat(Object.keys(chats)[0]);
    }
    setupVoiceRecognition();
    loadDarkMode();
    loadAssistantVoicePref();
  }

  // Event listeners
  newChatForm.addEventListener('submit', e => {
    e.preventDefault();
    createNewChat(newChatNameInput.value);
  });
  sendBtn.addEventListener('click', sendQuery);
    generateImageBtn.addEventListener('click', generateImage);
  voiceInputBtn.addEventListener('click', toggleVoiceInput);
  darkModeToggle.addEventListener('click', toggleDarkMode);
  voiceToggle.addEventListener('click', toggleAssistantVoice);

  promptInput.addEventListener('keydown', e => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      sendQuery();
    }
  });

  // Mic permission prompt buttons
  allowMicBtn.addEventListener('click', () => {
    hideMicPermissionPrompt();
    try {
      recognition.start();
    } catch (err) {
      console.error('Error starting recognition:', err);
      statusDiv.textContent = 'Error starting voice recognition: ' + err.message;
    }
  });

  denyMicBtn.addEventListener('click', () => {
    hideMicPermissionPrompt();
    statusDiv.textContent = 'Microphone permission denied.';
  });

  // Run initialization
  init();
</script>

</body>
</html>
